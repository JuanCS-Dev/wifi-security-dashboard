"""
Runchart Component Adapter for py_cui.

Adapter that converts Runchart component to py_cui TextBlock widget
with ASCII line charts generated by plotext.

Author: Dev Sênior Rafael
Date: 2025-11-11
Sprint: 3 (Plotext Integration)
"""

from typing import Any, List
from collections import deque
import py_cui
import plotext as plt
import io
import sys

from src.adapters.component_adapter import ComponentAdapter
from src.utils.ansi_stripper import strip_ansi_codes


# Color mapping: component color name → py_cui color code
COLOR_MAP = {
    'green': py_cui.GREEN_ON_BLACK,
    'yellow': py_cui.YELLOW_ON_BLACK,
    'red': py_cui.RED_ON_BLACK,
    'cyan': py_cui.CYAN_ON_BLACK,
    'blue': py_cui.BLUE_ON_BLACK,
    'magenta': py_cui.MAGENTA_ON_BLACK,
    'white': py_cui.WHITE_ON_BLACK,
}


class RunchartAdapter(ComponentAdapter):
    """
    Adapter for Runchart component → py_cui TextBlock with plotext charts.

    Generates ASCII line charts for time series data using plotext library.
    Maintains value history and renders dynamic charts.

    Example:
        >>> from src.components.runchart import Runchart
        >>> component = Runchart(config)
        >>> adapter = RunchartAdapter(component)
        >>> widget = adapter.create_widget(pycui_root, row=0, col=0, row_span=15, col_span=60)
        >>> adapter.update_widget({'system': {'cpu_percent': 45.2}})
    """

    def __init__(self, component: Any):
        """
        Initialize adapter.

        Args:
            component: Runchart component instance
        """
        super().__init__(component)

        # Extract Runchart-specific config
        self.max_samples: int = component.config.extra.get('max_samples', 60)
        self.marker: str = component.config.extra.get('marker', 'braille')

        # Value history (adapter maintains its own history for py_cui mode)
        self.history: deque = deque(maxlen=self.max_samples)

    def create_widget(
        self,
        pycui_root: py_cui.PyCUI,
        row: int,
        col: int,
        row_span: int,
        col_span: int
    ) -> Any:
        """
        Create py_cui TextBlock for runchart display.

        Args:
            pycui_root: PyCUI root instance
            row: Starting grid row
            col: Starting grid column
            row_span: Number of rows to span
            col_span: Number of columns to span

        Returns:
            py_cui TextBlock widget
        """
        # Create TextBlock widget
        widget = pycui_root.add_text_block(
            title=self.component.config.title,
            row=row,
            column=col,
            row_span=row_span,
            column_span=col_span
        )

        # Set initial color if specified
        if self.component.config.color in COLOR_MAP:
            widget.set_color(COLOR_MAP[self.component.config.color])

        # Store widget reference
        self.widget = widget

        return widget

    def update_widget(self, plugin_data: dict) -> None:
        """
        Update widget with new plugin data.

        Extracts numeric value, adds to history, generates chart with plotext.

        Args:
            plugin_data: Dictionary of plugin data
                {
                    'plugin_name': {'field': value, ...},
                    ...
                }
        """
        if not self.widget:
            return

        # Extract data from plugin
        plugin_name = self.component.config.plugin
        data_field = self.component.config.data_field

        if plugin_name not in plugin_data:
            self.widget.set_text("N/A - Plugin not available")
            return

        plugin_vals = plugin_data[plugin_name]

        if data_field not in plugin_vals:
            self.widget.set_text(f"N/A - Field '{data_field}' not found")
            return

        value = plugin_vals[data_field]

        # Convert to float and add to history
        try:
            numeric_value = float(value)
            self.history.append(numeric_value)
        except (ValueError, TypeError):
            # Skip non-numeric values
            return

        # Generate chart
        chart = self._generate_chart()

        # Update widget
        self.widget.set_text(chart)

    def _generate_chart(self) -> str:
        """
        Generate ASCII line chart using plotext.

        Returns:
            ASCII chart as string
        """
        if not self.history:
            return "No data yet..."

        # Convert deque to list for plotext
        data: List[float] = list(self.history)

        # Clear previous plot
        plt.clf()

        # Create line plot
        plt.plot(data, marker=self.marker)
        plt.title(self.component.config.title)
        plt.xlabel("Time")
        plt.ylabel("Value")

        # Set Y-axis limits for better visualization
        if len(data) > 1:
            min_val = min(data)
            max_val = max(data)

            # Calculate margin with minimum threshold to avoid division by zero
            value_range = max_val - min_val
            if value_range < 0.01:  # Values too close - use fixed margin
                margin = max(abs(max_val) * 0.1, 0.1)  # 10% of value or 0.1 minimum
            else:
                margin = value_range * 0.1  # 10% margin

            plt.ylim(min_val - margin if min_val - margin > 0 else 0,
                     max_val + margin)

        # Capture output to string
        output = io.StringIO()
        old_stdout = sys.stdout
        sys.stdout = output

        try:
            plt.show()
        finally:
            sys.stdout = old_stdout

        chart_text = output.getvalue()

        # CRITICAL FIX: Strip ANSI codes for py_cui compatibility
        # py_cui uses curses which does NOT interpret ANSI escape sequences
        # Without this, chart appears as garbage: ^[[48;5;15m instead of colors
        clean_chart = strip_ansi_codes(chart_text)

        return clean_chart

    def __repr__(self) -> str:
        """String representation for debugging."""
        return (
            f"RunchartAdapter("
            f"component={self.component.config.title}, "
            f"samples={len(self.history)}/{self.max_samples}, "
            f"marker={self.marker})"
        )
