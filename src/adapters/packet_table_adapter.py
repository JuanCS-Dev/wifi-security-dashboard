"""
PacketTable Component Adapter for py_cui.

Adapter that converts PacketTable component to py_cui TextBlock widget
with ASCII tables generated by tabulate.

Author: Dev Sênior Rafael
Date: 2025-11-11
Sprint: 5 (Grande Finale!)
"""

from typing import Any, Dict, List
import py_cui
from tabulate import tabulate

from src.adapters.component_adapter import ComponentAdapter


# Color mapping: component color name → py_cui color code
COLOR_MAP = {
    'green': py_cui.GREEN_ON_BLACK,
    'yellow': py_cui.YELLOW_ON_BLACK,
    'red': py_cui.RED_ON_BLACK,
    'cyan': py_cui.CYAN_ON_BLACK,
    'blue': py_cui.BLUE_ON_BLACK,
    'magenta': py_cui.MAGENTA_ON_BLACK,
    'white': py_cui.WHITE_ON_BLACK,
}


class PacketTableAdapter(ComponentAdapter):
    """
    Adapter for PacketTable component → py_cui TextBlock with tabulate tables.

    Generates Wireshark-style packet tables using tabulate library.
    Displays recent network packets with educational safety indicators.

    Example:
        >>> from src.components.packet_table import PacketTable
        >>> component = PacketTable(config)
        >>> adapter = PacketTableAdapter(component)
        >>> widget = adapter.create_widget(pycui_root, row=0, col=0, row_span=20, col_span=120)
        >>> adapter.update_widget({'packet_analyzer': {...}})
    """

    def __init__(self, component: Any):
        """
        Initialize adapter.

        Args:
            component: PacketTable component instance
        """
        super().__init__(component)

        # Extract PacketTable-specific config
        self.show_protocols: bool = component.config.extra.get('show_protocols', True)
        self.show_recent: bool = component.config.extra.get('show_recent', True)
        self.max_protocols: int = component.config.extra.get('max_protocols', 6)
        self.max_recent: int = component.config.extra.get('max_recent', 5)

    def create_widget(
        self,
        pycui_root: py_cui.PyCUI,
        row: int,
        col: int,
        row_span: int,
        col_span: int
    ) -> Any:
        """
        Create py_cui TextBlock for packet table display.

        Args:
            pycui_root: PyCUI root instance
            row: Starting grid row
            col: Starting grid column
            row_span: Number of rows to span
            col_span: Number of columns to span

        Returns:
            py_cui TextBlock widget
        """
        # Create TextBlock widget
        widget = pycui_root.add_text_block(
            title=self.component.config.title,
            row=row,
            column=col,
            row_span=row_span,
            column_span=col_span
        )

        # Set initial color if specified
        if self.component.config.color in COLOR_MAP:
            widget.set_color(COLOR_MAP[self.component.config.color])

        # Store widget reference
        self.widget = widget

        # Store dimensions for adaptive table sizing
        self.row_span = row_span
        self.col_span = col_span

        return widget

    def update_widget(self, plugin_data: dict) -> None:
        """
        Update widget with new plugin data.

        Extracts packet analysis data and generates table with tabulate.

        Args:
            plugin_data: Dictionary of plugin data
                {
                    'packet_analyzer': {
                        'top_protocols': {'HTTPS': 450, 'DNS': 89, ...},
                        'recent_packets': [
                            {'time': '14:32:15', 'source': '192.168.1.102', 'protocol': 'HTTPS', 'info': 'Gmail'},
                            ...
                        ],
                        ...
                    },
                    ...
                }
        """
        if not self.widget:
            return

        # Extract data from plugin
        plugin_name = self.component.config.plugin

        if plugin_name not in plugin_data:
            self.widget.set_text("N/A - Plugin not available")
            return

        plugin_vals = plugin_data[plugin_name]

        # Build complete table output
        output_parts = []

        # Section 1: Protocol Distribution (if enabled)
        if self.show_protocols and 'top_protocols' in plugin_vals:
            protocols_table = self._format_protocols(plugin_vals['top_protocols'])
            if protocols_table:
                output_parts.append("=" * 60)
                output_parts.append("TOP PROTOCOLS")
                output_parts.append("=" * 60)
                output_parts.append(protocols_table)
                output_parts.append("")

        # Section 2: Recent Packets (if enabled)
        if self.show_recent and 'recent_packets' in plugin_vals:
            packets_table = self._format_packets(plugin_vals['recent_packets'])
            if packets_table:
                output_parts.append("=" * 60)
                output_parts.append("RECENT PACKETS (Wireshark-style)")
                output_parts.append("=" * 60)
                output_parts.append(packets_table)

        # Combine all parts
        if output_parts:
            full_output = "\n".join(output_parts)
        else:
            full_output = "No packet data available"

        # Update widget
        self.widget.set_text(full_output)

    def _format_protocols(self, protocols: Dict[str, int]) -> str:
        """
        Format protocol distribution as table.

        Args:
            protocols: Dict of {protocol: packet_count}

        Returns:
            Formatted table string
        """
        if not protocols:
            return ""

        # Sort by count (descending) and limit
        items = sorted(protocols.items(), key=lambda x: x[1], reverse=True)[:self.max_protocols]

        # Calculate total for percentages
        total = sum(protocols.values())

        # Build table data
        table_data = []
        for protocol, count in items:
            percentage = (count / total * 100) if total > 0 else 0
            # Visual bar (simple ASCII)
            bar_length = int(percentage / 5)  # Max 20 chars
            bar = "█" * bar_length

            table_data.append([
                protocol,
                f"{count:,}",
                f"{percentage:.1f}%",
                bar
            ])

        # Generate table with tabulate
        table = tabulate(
            table_data,
            headers=["Protocol", "Packets", "%", "Distribution"],
            tablefmt="grid"
        )

        return table

    def _format_packets(self, packets: List[Dict]) -> str:
        """
        Format recent packets as Wireshark-style table.

        Args:
            packets: List of packet dicts with keys: time, source, destination, protocol, info

        Returns:
            Formatted table string
        """
        if not packets:
            return ""

        # Limit to max_recent
        recent = packets[-self.max_recent:] if len(packets) > self.max_recent else packets

        # Build table data
        table_data = []
        for packet in recent:
            # Extract fields (with defaults)
            time = packet.get('time', 'N/A')
            source = packet.get('source', 'N/A')
            dest = packet.get('destination', packet.get('dest', 'N/A'))
            protocol = packet.get('protocol', 'N/A')
            info = packet.get('info', '')

            # Truncate long fields
            source = self._truncate(source, 15)
            dest = self._truncate(dest, 15)
            info = self._truncate(info, 25)

            # Add educational safety flag for HTTP
            if protocol == 'HTTP':
                info = f"{info} ⚠️ UNSAFE"
            elif protocol == 'HTTPS':
                info = f"{info} ✓"

            table_data.append([
                time,
                source,
                dest,
                protocol,
                info
            ])

        # Generate table with tabulate
        table = tabulate(
            table_data,
            headers=["Time", "Source", "Destination", "Protocol", "Info"],
            tablefmt="grid"
        )

        return table

    def _truncate(self, text: str, max_len: int) -> str:
        """
        Truncate text with ellipsis if too long.

        Args:
            text: Text to truncate
            max_len: Maximum length

        Returns:
            Truncated text
        """
        if len(text) <= max_len:
            return text
        return text[:max_len - 3] + "..."

    def __repr__(self) -> str:
        """String representation for debugging."""
        return (
            f"PacketTableAdapter("
            f"component={self.component.config.title}, "
            f"protocols={self.show_protocols}, "
            f"recent={self.show_recent})"
        )
